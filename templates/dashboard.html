{% extends "base.html" %}

{% block container_class %}container-fluid p-3 h-100{% endblock %}

{% block content %}
<div class="row h-100">
    <!-- Header Row (Full Width) -->
    <div class="col-12 mb-3">
        <div class="d-flex justify-content-between align-items-center">
            <div>
                <!-- Status or other info could go here -->
            </div>
            <div>
                {% if can_interact %}
                <a href="/settings" class="btn btn-outline-secondary btn-sm" data-i18n="settings_btn">‚öôÔ∏è Settings</a>
                {% endif %}
            </div>
        </div>
    </div>

    <!-- Left Column: Gauges + Map -->
    <div class="col-lg-7 d-flex flex-column h-100">
        <!-- Gauges Row -->
        <div class="row text-center mb-3">
            <div class="col-3">
                <div class="card shadow-sm gauge-card">
                    <div class="card-body py-2">
                        <small class="text-muted" data-i18n="altitude">ALTITUDE</small>
                        <h4 id="data-altitude" class="card-title mb-0">0 FT</h4>
                    </div>
                </div>
            </div>
            <div class="col-3">
                <div class="card shadow-sm gauge-card">
                    <div class="card-body py-2">
                        <small class="text-muted" data-i18n="airspeed">AIRSPEED</small>
                        <h4 id="data-airspeed" class="card-title mb-0">0 KTS</h4>
                    </div>
                </div>
            </div>
            <div class="col-3">
                <div class="card shadow-sm gauge-card">
                    <div class="card-body py-2">
                        <small class="text-muted" data-i18n="heading">HEADING</small>
                        <h4 id="data-heading" class="card-title mb-0">0¬∞</h4>
                    </div>
                </div>
            </div>
            <div class="col-3">
                <div class="card shadow-sm gauge-card">
                    <div class="card-body py-2">
                        <small class="text-muted">VS</small>
                        <h4 id="data-vs" class="card-title mb-0 text-info">0 FPM</h4>
                    </div>
                </div>
            </div>
        </div>

        <!-- Visuals Tabs -->
        <ul class="nav nav-tabs mb-2" id="visualTabs" role="tablist">
            <li class="nav-item" role="presentation">
                <button class="nav-link active" id="map-tab" data-bs-toggle="tab" data-bs-target="#map-pane"
                    type="button" role="tab" data-i18n="tab_map">Map</button>
            </li>
            <li class="nav-item" role="presentation">
                <button class="nav-link" id="radar-tab" data-bs-toggle="tab" data-bs-target="#radar-pane" type="button"
                    role="tab" data-i18n="tab_radar">Radar (Traffic)</button>
            </li>
        </ul>

        <div class="tab-content flex-grow-1 border rounded shadow-sm bg-white"
            style="min-height: 400px; height: calc(100vh - 300px);">
            <!-- Map Pane -->
            <div class="tab-pane fade show active h-100 w-100" id="map-pane" role="tabpanel">
                <div id="map" class="h-100 w-100"></div>
                <!-- Â∑¶‰∏ãËßíÂú∞ÂõæÂ∑•ÂÖ∑Âå∫ / Left-bottom Map Toolbar (Clear Trail Only) -->
                <div class="control-stack position-absolute" style="bottom: 20px; left: 20px; z-index: 1000;">
                    <button id="btn-clear-track" class="btn btn-sm btn-warning" title="Ê∏ÖÈô§Ëà™Ëøπ / Clear Track"
                        data-i18n="clear_track_btn">
                        üóëÔ∏è <span data-i18n="clear_track_btn">Clear Trail</span>
                    </button>
                </div>
            </div>
            <!-- Radar Pane -->
            <div class="tab-pane fade h-100 w-100 position-relative bg-dark" id="radar-pane" role="tabpanel">
                <canvas id="radarCanvas" class="w-100 h-100"></canvas>
                <div class="position-absolute top-0 end-0 p-2 text-success small monospace">
                    RANGE: <span id="radar-range">10</span> NM
                </div>
            </div>
        </div>
    </div>

    <!-- Right Column: Chat + PTT -->
    <div class="col-lg-5 d-flex flex-column h-100 ps-lg-4">
        <div class="card flex-grow-1 shadow-sm mb-3" style="min-height: 200px;">
            <div class="card-header bg-white d-flex justify-content-between align-items-center py-2">
                <strong data-i18n="comms_log">Comms Log</strong>
                <div>
                    <span id="status-badge" class="badge bg-secondary" data-i18n="connecting">Connecting...</span>
                </div>
            </div>
            <div class="card-body p-2" id="log-container"
                style="overflow-y: auto; max-height: calc(100vh - 300px); background-color: #f8f9fa;">
                <!-- Chat messages go here -->
            </div>
            {% if can_interact %}
            <div class="card-footer bg-white p-2">
                <div class="input-group">
                    <input type="text" id="text-input" class="form-control" placeholder="Type your message..."
                        aria-label="Type your message" data-i18n-placeholder="type_message_placeholder">
                    <button class="btn btn-outline-primary" type="button" id="btn-send-text"
                        data-i18n="send_btn">Send</button>
                </div>
            </div>
            {% else %}
            <div class="card-footer bg-light p-2 text-center text-muted">
                <small data-i18n="readonly_notice">Read-only mode - You can only view</small>
            </div>
            {% endif %}
        </div>

        {% if can_interact %}
        <!-- ÈÄöËÆØÈ¢ëÈÅìÈÄâÊã©Âô® / Radio Channel Selector -->
        <div class="btn-group w-100 mb-2" role="group" aria-label="Radio channel selector">
            <input type="radio" class="btn-check" name="radio-channel" id="radio-atc" value="atc" checked>
            <label class="btn btn-outline-primary" for="radio-atc" data-i18n="radio_atc">üì° ATC</label>

            <input type="radio" class="btn-check" name="radio-channel" id="radio-crew" value="crew">
            <label class="btn btn-outline-pink" for="radio-crew" style="border-color: #e83e8c; color: #e83e8c;"
                data-i18n="radio_crew">üë• Crew</label>
        </div>

        <!-- ‰πòÂä°ÁªÑÈÄöËØùÊåâÈíÆ / Cabin Crew Button (‰ªÖÂú®CrewÊ®°ÂºèÊòæÁ§∫) -->
        <div id="crew-controls" class="d-none mt-2">
            <div class="d-flex gap-2">
                <button class="btn btn-outline-success btn-sm flex-grow-1" onclick="sendCabinIntercom('status')"
                    data-i18n="cabin_status">Status</button>
                <button class="btn btn-outline-primary btn-sm flex-grow-1" onclick="sendCabinIntercom('chat')"
                    data-i18n="cabin_chat">Chat</button>
            </div>
            <div class="d-flex gap-2 mt-2 border-top pt-2">
                <button class="btn btn-outline-warning btn-sm" onclick="sendCabinIntercom('boarding')"
                    data-i18n="btn_boarding">üõ´ Boarding</button>
                <button class="btn btn-outline-warning btn-sm" onclick="sendCabinIntercom('deboarding')"
                    data-i18n="btn_deboarding">üõ¨ Deboarding</button>
                <button class="btn btn-outline-danger btn-sm" onclick="sendCabinIntercom('stop_ambience')"
                    data-i18n="btn_stop_sound">üîá Stop</button>
            </div>
        </div>

        <button id="ptt-btn" class="btn btn-primary btn-lg w-100 py-3 fw-bold shadow-sm mb-3" data-i18n="ptt_btn">PUSH
            TO TALK</button>
        {% endif %}
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // socket is defined in base.html as window.socket
    const socket = window.socket;

    // Global language setting
    const lang = localStorage.getItem('language') || 'en';

    const logContainer = document.getElementById('log-container');
    const altitudeEl = document.getElementById('data-altitude');
    const airspeedEl = document.getElementById('data-airspeed');
    const headingEl = document.getElementById('data-heading');
    const vsEl = document.getElementById('data-vs');

    // Radar Logic
    const radarCanvas = document.getElementById('radarCanvas');
    let trafficData = []; // [{callsign, lat, lon, alt, hdg, spd, vs, ...}]
    let ownship = { lat: 0, lon: 0, hdg: 0, alt: 0 };
    let radarRange = 10; // NM

    function initRadar() {
        if (!radarCanvas) return;

        // Resize observer to handle tab switches
        const resizeObserver = new ResizeObserver(() => {
            radarCanvas.width = radarCanvas.offsetWidth;
            radarCanvas.height = radarCanvas.offsetHeight;
        });
        resizeObserver.observe(radarCanvas.parentElement);

        drawRadar();
    }

    // Haversine distance/bearing
    function getRelPos(lat1, lon1, lat2, lon2) {
        const R = 3440.065; // NM
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
            Math.sin(dLon / 2) * Math.sin(dLon / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        const d = R * c;

        const y = Math.sin(dLon) * Math.cos(lat2 * Math.PI / 180);
        const x = Math.cos(lat1 * Math.PI / 180) * Math.sin(lat2 * Math.PI / 180) -
            Math.sin(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.cos(dLon);
        let brng = Math.atan2(y, x) * 180 / Math.PI;
        return { dist: d, brng: (brng + 360) % 360 };
    }

    function drawRadar() {
        if (!radarCanvas) return;
        const ctx = radarCanvas.getContext('2d');
        const w = radarCanvas.width;
        const h = radarCanvas.height;
        const cx = w / 2;
        const cy = h / 2;
        const scale = Math.min(w, h) / 2 / radarRange; // px per NM

        // Clear
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, w, h);

        // Draw Rings
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let r = 2.5; r <= radarRange; r += 2.5) {
            ctx.arc(cx, cy, r * scale, 0, 2 * Math.PI);
        }
        ctx.stroke();

        // Draw Crosshair
        ctx.beginPath();
        ctx.moveTo(cx - 10, cy); ctx.lineTo(cx + 10, cy);
        ctx.moveTo(cx, cy - 10); ctx.lineTo(cx, cy + 10);
        ctx.stroke();

        // Draw Traffic
        ctx.font = '10px monospace';
        trafficData.forEach(ac => {
            if (!ownship.lat) return;

            const rel = getRelPos(ownship.lat, ownship.lon, ac.lat, ac.lon);
            if (rel.dist > radarRange) return;

            // Calculate screen pos (Heading up)
            // If heading up, ownship heading is 0 deg (Up)
            // Target relative bearing = true_bearing - ownship_heading
            const relBrng = (rel.brng - ownship.hdg + 360) % 360;
            const rad = (relBrng - 90) * Math.PI / 180; // canvas 0 is right (East)

            const x = cx + Math.cos(rad) * rel.dist * scale;
            const y = cy + Math.sin(rad) * rel.dist * scale;

            // Icon
            ctx.fillStyle = ac.state === 'AIRBORNE' ? '#0f0' : '#ff0';
            ctx.beginPath();
            ctx.arc(x, y, 3, 0, 2 * Math.PI);
            ctx.fill();

            // Label
            ctx.fillStyle = '#fff';
            // Vertical separation
            const altDiff = (ac.alt - ownship.alt) / 100; // in 100s of ft
            const altStr = (altDiff > 0 ? '+' : '') + Math.round(altDiff);
            ctx.fillText(`${ac.callsign} ${altStr}`, x + 5, y);
        });

        requestAnimationFrame(drawRadar);
    }

    // Init Radar on load
    initRadar();

    const pttBtn = document.getElementById('ptt-btn');
    const textInput = document.getElementById('text-input');
    const btnSendText = document.getElementById('btn-send-text');

    // --- Text Input Logic ---
    function sendText() {
        if (!textInput) return;
        const text = textInput.value.trim();
        if (text) {
            socket.emit('text_input', text);
            textInput.value = '';
        }
    }

    if (btnSendText) {
        btnSendText.addEventListener('click', sendText);
    }
    if (textInput) {
        textInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') { sendText(); }
        });
    }

    // --- Gamepad PTT Logic (Read Only) ---
    // Dashboard just reads the binding from localStorage
    let gamepadIndex = -1;
    let pttButtonIndex = -1;
    let wasPressed = false;

    function loadPTTBinding() {
        const saved = localStorage.getItem('ptt_binding');
        if (saved) {
            const b = JSON.parse(saved);
            gamepadIndex = b.gp;
            pttButtonIndex = b.btn;
            console.log("PTT Bound to GP:", gamepadIndex, "BTN:", pttButtonIndex);
        }
    }

    function gamepadLoop() {
        const gamepads = navigator.getGamepads ? navigator.getGamepads() : [];
        if (!gamepads) return;

        for (let i = 0; i < gamepads.length; i++) {
            // Only listen to the bound gamepad
            if (i === gamepadIndex && pttButtonIndex !== -1) {
                const gp = gamepads[i];
                if (gp && gp.buttons[pttButtonIndex]) {
                    const isPressed = gp.buttons[pttButtonIndex].pressed;
                    if (isPressed && !wasPressed) startRecording();
                    else if (!isPressed && wasPressed) stopRecording();
                    wasPressed = isPressed;
                }
            }
        }
        requestAnimationFrame(gamepadLoop);
    }

    window.addEventListener("gamepadconnected", gamepadLoop);
    loadPTTBinding(); // Load immediately
    requestAnimationFrame(gamepadLoop);

    // --- Map Setup ---
    let map = L.map('map').setView([40.08, 116.58], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '¬© OpenStreetMap'
    }).addTo(map);
    let aircraftMarker;

    // Issue 2: Altitude-colored track segments
    let flightPathNodes = [];  // [[lat, lng], ...]
    const flightPathSegments = [];  // L.polyline objects for each segment
    var flightPathAlts = [];
    let flightModeIFR = true;  // IFR by default (max 40000ft), VFR max 15000ft
    let lastValidPosition = null;  // For teleport detection

    // Color palette: Ëìù(Âú∞Èù¢) ‚Üí Áªø ‚Üí Ê©ô ‚Üí ÈªÑ ‚Üí Á∫¢ ‚Üí Á¥´
    function getAltitudeColor(alt) {
        const maxAlt = flightModeIFR ? 40000 : 15000;
        const ratio = Math.min(alt / maxAlt, 1.0);

        // Ground: Blue gradient (< 500ft AGL)
        if (alt < 500) {
            // Interpolate from dark blue to light blue
            const t = alt / 500;
            return interpolateColor('#1e3a5f', '#3b82f6', t);
        }

        // Altitude bands: Áªø ‚Üí Ê©ô ‚Üí ÈªÑ ‚Üí Á∫¢ ‚Üí Á¥´
        const colors = ['#22c55e', '#f97316', '#eab308', '#ef4444', '#a855f7'];
        const index = Math.min(Math.floor(ratio * (colors.length - 1)), colors.length - 2);
        const t = (ratio * (colors.length - 1)) - index;
        return interpolateColor(colors[index], colors[index + 1], t);
    }

    // Helper: Interpolate between two hex colors
    function interpolateColor(c1, c2, t) {
        const hex = (c) => parseInt(c.slice(1), 16);
        const r1 = (hex(c1) >> 16) & 255, g1 = (hex(c1) >> 8) & 255, b1 = hex(c1) & 255;
        const r2 = (hex(c2) >> 16) & 255, g2 = (hex(c2) >> 8) & 255, b2 = hex(c2) & 255;
        const r = Math.round(r1 + (r2 - r1) * t);
        const g = Math.round(g1 + (g2 - g1) * t);
        const b = Math.round(b1 + (b2 - b1) * t);
        return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
    }

    // Add IFR/VFR selector and altitude legend to map
    const legend = L.control({ position: 'bottomright' });
    legend.onAdd = function (map) {
        const div = L.DomUtil.create('div', 'altitude-legend');
        div.style.cssText = 'background:rgba(0,0,0,0.7);padding:8px 12px;border-radius:6px;color:#fff;font-size:11px;line-height:1.6;';
        div.innerHTML = `
            <div style="font-weight:bold;margin-bottom:4px;">È´òÂ∫¶ / Altitude</div>
            <div style="margin-bottom:6px;">
                <select id="flightModeSelect" style="width:100%;padding:2px;border-radius:3px;font-size:10px;">
                    <option value="IFR" selected>IFR (0-40,000ft)</option>
                    <option value="VFR">VFR (0-15,000ft)</option>
                </select>
            </div>
            <div><span style="display:inline-block;width:12px;height:12px;background:linear-gradient(to right,#1e3a5f,#3b82f6);margin-right:6px;border-radius:2px;"></span>Âú∞Èù¢ &lt;500ft</div>
            <div><span style="display:inline-block;width:12px;height:12px;background:#22c55e;margin-right:6px;border-radius:2px;"></span>‰ΩéÁ©∫</div>
            <div><span style="display:inline-block;width:12px;height:12px;background:#f97316;margin-right:6px;border-radius:2px;"></span>‰∏≠‰ΩéÁ©∫</div>
            <div><span style="display:inline-block;width:12px;height:12px;background:#eab308;margin-right:6px;border-radius:2px;"></span>‰∏≠Á©∫</div>
            <div><span style="display:inline-block;width:12px;height:12px;background:#ef4444;margin-right:6px;border-radius:2px;"></span>È´òÁ©∫</div>
            <div><span style="display:inline-block;width:12px;height:12px;background:#a855f7;margin-right:6px;border-radius:2px;"></span>Ë∂ÖÈ´òÁ©∫</div>
        `;
        return div;
    };
    legend.addTo(map);

    // IFR/VFR mode change handler
    document.addEventListener('change', (e) => {
        if (e.target && e.target.id === 'flightModeSelect') {
            flightModeIFR = e.target.value === 'IFR';
            console.log('Flight mode changed to:', flightModeIFR ? 'IFR' : 'VFR');
        }
    });

    // Fix Map resize issue in tab
    document.getElementById('map-tab').addEventListener('shown.bs.tab', function () {
        map.invalidateSize();
    });

    socket.on('telemetry_update', (data) => {
        if (altitudeEl) altitudeEl.innerText = Math.round(data.altitude || 0);
        if (airspeedEl) airspeedEl.innerText = Math.round(data.airspeed || 0);
        if (headingEl) headingEl.innerText = Math.round(data.heading || 0);

        // Update Ownship for Radar
        ownship.lat = data.latitude;
        ownship.lon = data.longitude;
        ownship.hdg = data.heading;
        ownship.alt = data.altitude;

        // VS (Vertical Speed) with FPM formatting and color
        if (vsEl) {
            const vs = Math.round(data.vertical_speed || 0);
            vsEl.innerText = `${vs >= 0 ? '+' : ''}${vs} FPM`;
            // Color coding: green for climb, red for descent, neutral otherwise
            if (vs > 100) {
                vsEl.classList.remove('text-danger', 'text-muted');
                vsEl.classList.add('text-success');
            } else if (vs < -100) {
                vsEl.classList.remove('text-success', 'text-muted');
                vsEl.classList.add('text-danger');
            } else {
                vsEl.classList.remove('text-success', 'text-danger');
                vsEl.classList.add('text-muted');
            }
        }

        if (data.latitude && data.longitude) {
            const latLng = [data.latitude, data.longitude];
            const alt = data.altitude || 0;

            if (!aircraftMarker) {
                // Create Ownship Marker
                aircraftMarker = L.marker(latLng).addTo(map);
                map.setView(latLng, 13);
            } else {
                aircraftMarker.setLatLng(latLng);
            }

            // Issue 2: Altitude-colored track segment with teleport filtering
            // Teleport detection: skip segments > 5nm (9260m)
            const teleportThreshold = 9260; // 5nm in meters
            let shouldDrawSegment = true;

            if (lastValidPosition) {
                const distFromLast = map.distance(lastValidPosition, latLng);
                if (distFromLast > teleportThreshold) {
                    console.log(`Áû¨ÁßªÊ£ÄÊµãÔºöË∑≥Ëøá ${(distFromLast / 1852).toFixed(1)}nm ÁöÑÁ∫øÊÆµ`);
                    shouldDrawSegment = false;
                    // Still update position but don't draw line
                }
            }

            // Only draw if minimum distance met (50m) and no teleport
            if (flightPathNodes.length === 0 || map.distance(flightPathNodes[flightPathNodes.length - 1], latLng) > 50) {
                if (shouldDrawSegment && flightPathNodes.length > 0) {
                    // Create gradient-colored segment
                    const lastNode = flightPathNodes[flightPathNodes.length - 1];
                    const color = getAltitudeColor(alt);
                    const segment = L.polyline([lastNode, latLng], { color: color, weight: 3 }).addTo(map);
                    flightPathSegments.push(segment);
                }

                flightPathNodes.push(latLng);
                flightPathAlts.push(alt);
                lastValidPosition = latLng;

                // Persist path history (debounce)
                if (flightPathNodes.length % 5 === 0) {
                    localStorage.setItem('flight_path', JSON.stringify({ nodes: flightPathNodes, alts: flightPathAlts }));
                }
            }
        }
    });

    // Traffic Update Listener
    socket.on('traffic_update', (data) => {
        trafficData = data;
    });

    // Landing Review Listener (Show parsed roast in chat)
    socket.on('landing_review', (data) => {
        if (!logContainer) return;

        const div = document.createElement('div');
        div.className = 'mb-2 p-2 bg-warning bg-opacity-10 border border-warning rounded';
        div.innerHTML = `
            <div class="d-flex justify-content-between">
                <strong>üë®‚Äç‚úàÔ∏è Flight Instructor</strong>
                <span class="badge bg-${getGradeColor(data.score)}">${data.score}</span>
            </div>
            <p class="mb-0 mt-1 fst-italic">"${data.comment}"</p>
            <div class="mt-1 small text-muted">
                G-Force: ${data.g_force.toFixed(2)}G | Bounces: ${data.bounces}
            </div>
        `;
        logContainer.appendChild(div);
        logContainer.scrollTop = logContainer.scrollHeight;
    });

    function getGradeColor(grade) {
        if (grade === 'S' || grade === 'A') return 'success';
        if (grade === 'B' || grade === 'C') return 'warning';
        return 'danger';
    }

    // Emergency Alert Listener
    socket.on('emergency_alert', (data) => {
        // data: {type: 'engine_fire', message: '...'}
        const div = document.createElement('div');
        div.className = 'mb-2 p-2 bg-danger text-white border border-light rounded fw-bold text-center shake-anim';
        div.innerHTML = `üö® ${data.message} üö®`;
        logContainer.appendChild(div);
        logContainer.scrollTop = logContainer.scrollHeight;
    });

    // Warning Sound Listener
    socket.on('play_warning_sound', (data) => {
        try {
            const audio = new Audio(`/static/sounds/${data.sound}`);
            audio.volume = 1.0;
            audio.play().catch(e => console.warn("Audio play blocked", e));
        } catch (e) { console.error(e); }
    });

    let currentAmbience = null;
    socket.on('play_ambience', (data) => {
        if (currentAmbience) {
            currentAmbience.pause();
            currentAmbience = null;
        }
        const audio = new Audio('/static/sounds/' + data.sound);
        audio.loop = data.loop || false;
        audio.volume = 0.5;
        audio.play().catch(e => console.log("Ambience play failed:", e));
        currentAmbience = audio;
    });

    socket.on('stop_ambience', () => {
        if (currentAmbience) {
            currentAmbience.pause();
            currentAmbience = null;
        }
    });

    // Load persisted flight path
    function loadFlightPath() {
        const saved = localStorage.getItem('flight_path');
        if (saved) {
            try {
                const data = JSON.parse(saved);
                if (data.nodes && data.nodes.length > 0) {
                    console.log("Restoring flight path:", data.nodes.length, "points");
                    flightPathNodes = data.nodes;
                    flightPathAlts = data.alts || []; // Compatibility

                    // Reconstruct path on map
                    for (let i = 0; i < flightPathNodes.length - 1; i++) {
                        const start = flightPathNodes[i];
                        const end = flightPathNodes[i + 1];
                        const alt = flightPathAlts[i + 1] || 0;
                        const color = getAltitudeColor(alt);
                        L.polyline([start, end], { color: color, weight: 3 }).addTo(map);
                    }
                }
            } catch (e) {
                console.error("Failed to load flight path history:", e);
                localStorage.removeItem('flight_path');
            }
        }
    }
    // Call load on init
    loadFlightPath();

    // --- Clear Flight Trail (Fix #1, #6) ---
    function clearMapTrail() {
        // Clear the polylines from the map
        map.eachLayer(layer => {
            if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
                map.removeLayer(layer);
            }
        });
        // Clear stored data
        flightPathNodes = [];
        flightPathAlts = [];
        localStorage.removeItem('flight_path');
        console.log("Flight trail cleared.");
    }

    // Bind Clear Track button
    const btnClearTrack = document.getElementById('btn-clear-track');
    if (btnClearTrack) {
        btnClearTrack.addEventListener('click', clearMapTrail);
    }

    // --- Audio & socket logic same as before ---
    let mediaRecorder;
    let audioChunks = [];

    socket.on('connect', () => {
        const el = document.getElementById('status-badge');
        el.className = 'badge bg-warning'; // Warning until Sim connects
        const lang = localStorage.getItem('language') || 'en';
        el.innerText = (lang === 'zh') ? "ÊúçÂä°Âô®Â∑≤ËøûÊé•" : "Server Connected";
    });

    socket.on('disconnect', () => {
        const el = document.getElementById('status-badge');
        el.className = 'badge bg-danger';
        const lang = localStorage.getItem('language') || 'en';
        el.innerText = (lang === 'zh') ? "ÊúçÂä°Âô®Êñ≠ÂºÄ" : "Server Disconnected";
    });

    socket.on('sim_status', (data) => {
        const el = document.getElementById('status-badge');
        const lang = localStorage.getItem('language') || 'en';
        if (data.connected) {
            el.className = 'badge bg-success';
            el.innerText = (lang === 'zh') ? "È£ûË°åÊ®°ÊãüÂô®Â∑≤ËøûÊé•" : "Sim Connected";
        } else {
            el.className = 'badge bg-secondary';
            el.innerText = (lang === 'zh') ? "ÂØªÊâæÊ®°ÊãüÂô®..." : "Searching Sim...";
        }
    });

    // Request initial status (fix for refresh race condition)
    socket.emit('request_sim_status');

    // ÁÆ°Âà∂ËßíËâ≤È¢úËâ≤Êò†Â∞Ñ / Controller Role Color Mapping
    const roleColorMap = {
        'Ground': { bg: '#8B4513', text: 'white' },    // Ë§êËâ≤
        'Tower': { bg: '#28a745', text: 'white' },     // ÁªøËâ≤
        'Departure': { bg: '#007bff', text: 'white' }, // ËìùËâ≤
        'Center': { bg: '#6f42c1', text: 'white' },    // Á¥´Ëâ≤
        'Approach': { bg: '#fd7e14', text: 'white' },  // Ê©ôËâ≤
        'Emergency': { bg: '#dc3545', text: 'white' }, // Á∫¢Ëâ≤
        'ATIS': { bg: '#6c757d', text: 'white' },      // ÁÅ∞Ëâ≤
        'Cabin': { bg: '#e83e8c', text: 'white' },     // Á≤âËâ≤
        'SYSTEM': { bg: '#343a40', text: 'white' },    // Ê∑±ÁÅ∞
        'Pilot': { bg: '#17a2b8', text: 'white' }      // ÈùíËâ≤
    };

    function getRoleColor(sender) {
        // Á≤æÁ°ÆÂåπÈÖç
        if (roleColorMap[sender]) return roleColorMap[sender];
        // Ê®°Á≥äÂåπÈÖç (Â¶Ç "ZBAA Ground" -> Ground)
        for (const role in roleColorMap) {
            if (sender.includes(role)) return roleColorMap[role];
        }
        // ÈªòËÆ§ ATC È¢úËâ≤
        return { bg: '#28a745', text: 'white' };
    }

    socket.on('chat_log', (data) => {
        const div = document.createElement('div');
        const colors = getRoleColor(data.sender);
        const align = data.sender === 'Pilot' ? 'text-end' : 'text-start';
        div.className = `mb-2 p-2 rounded ${align}`;
        div.style.cssText = `background-color: ${colors.bg}; color: ${colors.text};`;
        div.innerHTML = `<strong>${data.sender}:</strong> ${data.text}`;
        logContainer.appendChild(div);
        logContainer.scrollTop = logContainer.scrollHeight;
    });

    // Audio Playback
    socket.on('audio_stream', (data) => {
        try {
            const audioData = atob(data.data);
            const audioBytes = new Uint8Array(audioData.length);
            for (let i = 0; i < audioData.length; i++) {
                audioBytes[i] = audioData.charCodeAt(i);
            }
            const audioBlob = new Blob([audioBytes], { type: 'audio/mpeg' });
            const audioUrl = URL.createObjectURL(audioBlob);
            new Audio(audioUrl).play().catch(e => console.error(e));
        } catch (e) { console.error(e); }
    });

    // Background Chatter Audio (lower volume)
    let chatterVolume = 0.4;  // Background chatter volume (0-1)
    socket.on('chatter_audio', (data) => {
        try {
            const audioData = atob(data.data);
            const audioBytes = new Uint8Array(audioData.length);
            for (let i = 0; i < audioData.length; i++) {
                audioBytes[i] = audioData.charCodeAt(i);
            }
            const audioBlob = new Blob([audioBytes], { type: 'audio/mpeg' });
            const audioUrl = URL.createObjectURL(audioBlob);
            const audio = new Audio(audioUrl);
            audio.volume = chatterVolume;  // Lower volume for background
            audio.play().catch(e => console.error(e));
        } catch (e) { console.error(e); }
    });

    // Ducking: reduce chatter volume when player is speaking
    socket.on('duck_audio', (data) => {
        if (data.active) {
            chatterVolume = 0.1;  // Duck to 10%
        } else {
            chatterVolume = 0.4;  // Restore to 40%
        }
    });

    // PTT Recording
    const startRecording = () => {
        if (!pttBtn) return; // No PTT for readonly users
        navigator.mediaDevices.getUserMedia({ audio: true }).then(stream => {
            mediaRecorder = new MediaRecorder(stream);
            mediaRecorder.start();
            audioChunks = [];
            mediaRecorder.addEventListener("dataavailable", event => audioChunks.push(event.data));
            mediaRecorder.addEventListener("stop", () => socket.emit('voice_data', new Blob(audioChunks)));

            pttBtn.classList.remove('btn-primary');
            pttBtn.classList.add('btn-danger');

            const lang = localStorage.getItem('language') || 'en';
            pttBtn.innerText = (lang === 'zh') ? "Ê≠£Âú®‰º†Ëæì..." : "TRANSMITTING...";
        });
    };

    const stopRecording = () => {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
            if (pttBtn) {
                pttBtn.classList.add('btn-primary');
                pttBtn.classList.remove('btn-danger');

                const lang = localStorage.getItem('language') || 'en';
                pttBtn.innerText = (lang === 'zh') ? "Êåâ‰ΩèÈÄöËØù (PTT)" : "PUSH TO TALK";
            }
        }
    };

    // Events
    document.body.addEventListener('click', () => { new Audio(); }, { once: true });

    if (pttBtn) {
        pttBtn.addEventListener('mousedown', startRecording);
        pttBtn.addEventListener('mouseup', stopRecording);
        pttBtn.addEventListener('touchstart', (e) => { e.preventDefault(); startRecording(); });
        pttBtn.addEventListener('touchend', (e) => { e.preventDefault(); stopRecording(); });
    }

    document.addEventListener('keydown', (e) => {
        if (document.activeElement.tagName === 'INPUT') return;
        if (e.code === 'Space' && !e.repeat && pttBtn) { e.preventDefault(); startRecording(); }
    });
    document.addEventListener('keyup', (e) => {
        if (document.activeElement.tagName === 'INPUT') return;
        if (e.code === 'Space' && pttBtn) { e.preventDefault(); stopRecording(); }
    });

    // === ‰πòÂä°ÁªÑÊåâÈíÆ‰∫ã‰ª∂ / Cabin Crew Buttons ===
    const btnCabinStatus = document.getElementById('btn-cabin-status');
    const btnCabinChat = document.getElementById('btn-cabin-chat');

    if (btnCabinStatus) {
        btnCabinStatus.addEventListener('click', () => {
            console.log('Cabin Status requested');
            socket.emit('cabin_intercom', { action: 'status' });
        });
    }

    if (btnCabinChat) {
        btnCabinChat.addEventListener('click', () => {
            const message = prompt(lang === 'zh' ? 'ËæìÂÖ•ÁªôÊú∫ÁªÑÁöÑÊ∂àÊÅØ:' : 'Message to cabin crew:');
            if (message && message.trim()) {
                socket.emit('cabin_chat', { message: message.trim() });
            }
        });
    }

    // NOTE: Clear Track button handler moved to clearMapTrail() function above

    // === ÈÄöËÆØÈ¢ëÈÅìÂàáÊç¢Âô® / Radio Channel Selector ===
    const radioAtc = document.getElementById('radio-atc');
    const radioCrew = document.getElementById('radio-crew');
    const crewControls = document.getElementById('crew-controls');
    let currentChannel = 'atc'; // 'atc' or 'crew'

    if (radioAtc && radioCrew) {
        radioAtc.addEventListener('change', () => {
            currentChannel = 'atc';
            if (crewControls) crewControls.style.display = 'none';
            // Emit intercom toggle to backend
            socket.emit('toggle_intercom', { target: 'ATC' });
            console.log('Radio channel: ATC');
        });

        radioCrew.addEventListener('change', () => {
            currentChannel = 'crew';
            if (crewControls) crewControls.style.display = 'block';
            // Emit intercom toggle to backend
            socket.emit('toggle_intercom', { target: 'CABIN' });
            console.log('Radio channel: Crew');
        });
    }

    // Listen for emergency intercom mode (red border warning - for EMERGENCIES ONLY)
    socket.on('emergency_intercom', (data) => {
        if (data.active) {
            document.body.classList.add('cabin-emergency');
        } else {
            document.body.classList.remove('cabin-emergency');
        }
    });

    // ‰øÆÊîπÊ∂àÊÅØÂèëÈÄÅÈÄªËæëÔºåÊ†πÊçÆÈ¢ëÈÅìÂèëÈÄÅÂà∞‰∏çÂêåÁõÆÊ†á
    // ‰ΩøÁî®Á¨¨269Ë°åÂ∑≤Â£∞ÊòéÁöÑ textInput Âíå btnSendText ÂèòÈáè
    if (btnSendText && textInput) {
        // Ë¶ÜÁõñÂéüÊúâ onclickÔºåÊ∑ªÂä†Âü∫‰∫éÈ¢ëÈÅìÁöÑÊñ∞ÈÄªËæë
        btnSendText.onclick = () => {
            const text = textInput.value.trim();
            if (!text) return;

            if (currentChannel === 'atc') {
                socket.emit('user_text', { text: text, channel: 'atc' });
            } else {
                socket.emit('crew_message', { text: text, target: 'all' }); // all = FO + Purser
            }
            textInput.value = '';
        };

        textInput.onkeypress = (e) => {
            if (e.key === 'Enter') btnSendText.click();
        };
    }

</script>
{% endblock %}